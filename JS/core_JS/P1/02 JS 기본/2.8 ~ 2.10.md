## 8. 기본 연산자와 수학

#### 단항, 이항, 피연산자

- `피연산자`: 연산자가 연산을 수행하는 대상(인수로 불리기도 한다)
  - 피연산자를 하나만 받는 연산자는 `단항 연산자`라고 부른다. 피연산자의 부호를 뒤집는 마이너스 `-`가 단항 연산자의 대표적인 예시이다.
  - 두 개의 피연산자를 받는 연산자는 `이항 연산자`라고 부른다. 마이너스 역시 이항 연산자로 사용 가능하다. 이 때는 기호는 같지만 수행하는 연산이 다르다. 피연산자의 개수로 구분하게 된다.

```javascript
// calc.html
// 단항 연산자 -
let x = 1;
x = -x
alert(x); // -1 부호를 바꿔준다

// 이항 연산자
let x = 1, y = 3;
alert(y - x); // 2 뺄셈을 해준다
```

#### 수학

- `+`, `-`, `*`, `/` 외에서 `%`, `**` 라는 연산자가 있다.(나머지, 거듭제곱 연산자)
- `%`: 기호로 나타내지만, 퍼센트와는 연관이 없음.
  - `a % b`는 a를 b로 나눈 후 그 나머지를 정수로 반환해준다.

```javascript
// calc.html
alert(5 % 2); // 나머지 1 출력
alert(8 % 3) // 나머지 2 출력
```

- `**`:  `a ** b`를 평가하면 a를 b번 곱한 값이 반환된다. 이는 정수가 아닌 숫자에도 동작한다.

```javascript
// calc.html
alert(2 ** 2) // 4
alert(4 ** (1/2)) // 2(1/2 거듭제곱) 제곱근 구하기
```

#### 이항 연산자 `+`와 문자열 연결

- 이항 연산자 `+`의 피연산자로 문자열이 전달되면 덧셈 연산자는 덧셈이 아닌 문자열을 연결한다.
  - 따라서 이항 연산자 `+`를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다!!
  - 문자열 피연산자가 첫 번째인지 두 번째인지는 중요하지 않다. 하나가 문자열이면 나머지도 문자열로 변환된다.
  - 연산이 왼쪽에서 오른쪽으로 순차적으로 진행되기에 두 개 이상의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열간 병합이 일어난다.
  - 그 외 뺄셈, 나눗셈 연산자가 단지 숫자형의 피연산자만 다루고, 숫자형이 아닌 경우 그 자료형을 숫자형으로 바꾸는 것과는 대조된다.

```javascript
// calc.html
let s = "my" + "string";
alert(s); // mystring

alert('1' + 2); // "12"
alert(2 + '1'); // "21"
alert(2 + 2 + '1'); // "41" -- "221"이 아니다!!

alert(8 - '4'); // 2, '4'를 숫자로 바꾼다
alert('9' / '3'); // 3, 두 피연산자가 숫자로 바뀐 뒤 연산이 진행된다.
```

#### 단항 연산자 `+`와 숫자형으로의 변환

- 단항 연산자로도 사용이 가능하다.
  - 숫자에 단항 덧셈 연산자를 붙이면 아무 동작도 안하지만, 피연산자가 숫자가 아닌 경우 숫자형으로의 변환이 일어난다.

```javascript
// calc.html
let x = 1;
alert(+x); // 1 숫자에는 아무 영향 없음

let y = -2;
alert(+y); // -2

alert(+true); // 1 // 숫자형이 아닌 피연산자는 숫자형으로 변화
alert(+""); // 0
```

- 짧은 문법으로도 `Number(value)`와 동일한 일을 하게 한다.
  - 폼에서 가져오는 값이 문자열 형태일 때, 숫자로 변화시키기 위해 사용하게 된다.
  - 이항 덧셈 연산자를 사용하면 값이 문자열로 변해서 연결될 것이다.
  - 원하는대로 값을 더해주기 위해 단항 덧셈 연산자로 피연산자를 숫자형으로 변환할 수 있다.

```javascript
// calc.html
let apple = "2";
let lemon = "3";
alert(apple + lemon); // 23 이항 덧셈 연산자는 문자열을 연결함
alert(+apple + +lemon); // 5 이항 덧셈 연산자가 적용되기 전 피연산자들이 숫자형으로 변화했다!
alert(Number(apple) + Number(lemon)); // 같은 동작을 하지만 더 긴 코드
```

#### 연산자 우선순위

- 하나의 표현식에 둘 이상의 연산자가 있는 경우, 실행 순위가 우선순위에 의해 결정된다.
  - 정의된 우선순위가 마음에 들지 않는 경우 괄호를 사용해 기존의 우선순위를 무력화시키고 본인이 우선시하는 연산을 먼저 수행하게 할 수도 있다.
  - 연산자들의 우선 순위는 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence를 참고
  - 동일한 기호의 단항 연산자는 이항 연산자보다 우선순위가 더 높다

#### 할당 연산자

- 할당 연산자 `=`는 값을 반환한다.
  - `x = value`를 호출하면 value가 x에 쓰여지고 value가 반환된다.
  - `(a = b + 1)`은 a에 값을 할당하고, 그 값인 3을 반환한다. 반환값은 이어지는 표현식에도 사용된다.
  - 할당 연산자로 여러 개를 연결할수도 있다.(체이닝)
  - 할당 연산자를 여러 개 연결한 경우, 평가는 우측부터 진행된다. 우측에 있을 표현식이 평가되고, 그 결과가 좌측의 피연산자들에 순차적으로 할당된다. 결국 모든 피연산자(변수)가 단일 값을 공유하게 된다.
  - 물론 이렇게 하는 것보다 그냥 줄을 나눠서 하나씩 할당하는게 더 보기가 좋다.

```javascript
// calc.html
let x = 2 * 2 + 1;
alert(x) // 5

let a = 1;
let b = 2;
let c = 3 - (a = b + 1);

alert(a); // 3
alert(c); // 0

let a, b, c;
a = b = c = 2 + 2;
alert(a); // 4
alert(b); // 4
alert(c); // 4

c = 2 + 2;
b = c;
a = c;
```

#### 복합 할당 연산자

- 변수에 연산자를 적용하고 그 결과를 같은 변수에 저장해야 하는 경우 복합 할당 연산자 `+=` 또는 `*=`로 동일한 연산을 수행할 수 있다. 
  - 산술 연산자, 비트 연산자에도 적용 가능하다. 할당 연산자와 동일한 우선순위를 가진다.
  - 대부분 다른 연산자들이 실행된 뒤에 복합 할당 연산자가 실행된다.

```javascript
// calc.html
let n = 2;
n = n + 5;
n = n * 2;

let n = 2;
n += 5 // 2 + 5
n *= 2 // (2 + 5) * 2
alert(n) // 14

let n = 2;
n *= 3 + 5;
alert(n); // 16 *=의 우측이 먼저 평가된다(우선순위)
```

#### 증가/감소 연산자

- 숫자를 늘리거나, 줄이는 연산
  - 변수의 앞이나 뒤에만 쓸 수 있다! 값에 쓰려고 하는 경우 오류가 난다.
  - 피연산자 뒤에 오면 후위형, 앞에 오면 전위형이 된다.
  - 전위형은 증감 후의 새로운 값을 반환하는 반면, 후위형은 기존 값을 반환하고 연산 뒤 증감을 한다.
  - 반환 값을 사용하지 않는 경우, 전위형이나 후위형에 차이가 없다.
  - 값을 먼저 변화시킨 후 바로 사용시키려면 전위형을 사용한다.
  - 값을 변화시킬거지만 증감 전의 기존값을 사용하려면 후위형을 사용한다.
  - 표현식 중간에 사용할수도 있다. 증감 연산자는 대체로 대부분의 산술연산자보다 순위가 높기 때문에, 연산이 먼저 이루어진다.

```javascript
// calc.html
let counter = 2;
counter++; // + 1과 동일
alert(counter); // 3

let counter = 2;
counter--; // - 1과 동일
alert(counter); // 1

let counter = 1;
let a = counter++; 
alert(a); // 1!  만약 ++counter였다면 2가 반환될 것. counter++는 증가는 시키지만 증가 전의 기존 값을 반환

let counter = 0;
alert(++counter); // 값을 우선 증가시키고 그 값을 바로 사용하려면 전위형으로 사용해야 한다.

let counter = 1;
alert(2 * ++counter); // 4 먼저 카운터가 늘어나 2가 된 후 2 * 2 -> 4가 된다. 후위형이었다면 2가 나올 것
```

#### 비트 연산자

- 비트 연산자는 인수를 32비트 정수로 변환해 이전 연산을 수행한다.
  - AND(`&`), OR(`|`), XOR(`^`), NOT(`~`), LEFT SHIFT(`<<`), RIGHT SHIFT(`>>`)
  - 부호없는 오른쪽 시프트(`>>>`) 과 같은 연산자들이 있다.

#### 쉼표 연산자

- `,`는 좀처럼 보기 힘들고, 특이한 연산자이다. 코드를 짧게 쓰려는 의도로 사용되곤 한다.
  - 여러 표현식을 한 줄에서 평가할 수 있게 해주는데, 마지막 표현식의 결과만 반환된다는 것에 주의하자.
  - 우선순위가 매우 낮다! 그렇기에 괄호가 중요한 역할을 한다.

```javascript
// calc.html
let a = (1 + 2, 3 + 4);
alert(a); // 7 (3 + 4)
```

## 9. 비교 연산자

- JS에서 비교와 관련된 수학 연산은 일반적인 비교연산과 크게 다르지 않다.
  - 같음: `==` 같지 않음: `!=`

#### 불린형 반환

- `true`가 반환된다면 긍정, 참, 사실을, `false`가 반환된다면 부정, 거짓, 사실이 아님을 의미한다.
- 반환된 boolean값은 변수에 할당할 수 있다. 

```javascript
// comparison.html
alert( 2 > 1); // t
alert( 2 == 1); // f
alert( 2 != 1); // t

let result = 5 > 2; // 비교 결과 변수 할당
alert(result); // t
```

#### 문자열 비교

- JS는 `사전`순으로 문자열을 비교한다. 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단한다.
  - 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교한다. 
  - 두 문자열의 첫 글자를 비교한다. 
  - 한 문자열의 첫 글자가 더 크면, 해당 문자열이 나머지 문자열보다 크다고 결론내고 종료한다.
  - 첫 글자가 같으면, 마지막 글자까지 한 글자씩 같은 방식으로 비교한다.(끝날 때까지)
  - 비교가 끝나고, 문자열의 길이도 같으면 두 문자열이 동일하다 결론을 낸다.
  - 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론낸다.

```javascript
// comparison.html
alert('Z' > 'A'); // t
alert('Glow' > 'Glee'); // t
alert('Bee' > 'Be'); // t
```

- 정확히 말하자면 사전순이라기보다는 유니코드 순서다!
  - 일반적인 사전, 전화번호부의 정렬 알고리즘과의 차이는 대/소문자를 따진다는 것이다.
  - JS 내부에서 사용하는 인코딩 표인 유니코드에선 소문자가 대문자보다 인덱스가 더 크기 때문에, 소문자가 같은 문자의 대문자보다 더 크다.

#### 다른 형을 가진 값 간의 비교

- 만약 비교하려는 값의 자료형이 다르다면 JS는 이 값들을 숫자형으로 바꾼다.
  - `true`는 1, `false`는 0으로 변환된 후 비교가 이루어진다.
  - 아래의 예시 중 `0`과 `"0"`은 `==`비교시 true를 반환하지만, 논리 평가시 T/F가 나뉜다.
  - 동등 비교 연산자 `==`는 피연산자를 숫자형으로 바꾸기 때문에 둘 간의 비교 결과가 true가 나오지만,  `Boolean`을 사용해 명시적으로 형 변환을 하는 경우는 이야기가 다르다. JS에서는 비어있지 않은 문자열은 언제나 `true`를 반환하기에, `0`과 `"0"`은 Boolean으로는 참과 거짓이 나뉘게 된다.

```javascript
// comparison.html
alert( true == 1); // t
alert( false == 0); // t

let a = 0;
alert(Boolean(a)); // f

let b = "0";
alert(Boolean(b)); // t

alert(a == b); // t
```

#### 일치 연산자

- 동등 연산자 `==`는 위에서 보았듯 `0`과 `false`를 제대로 구별하지 못한다.

  - 피연산자가 빈 문자열일 때도 같은 문제가 생긴다.
  - 동등 연산자가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문이다.
  - 빈 문자열과 false는 숫자형으로 보면 0이 된다.
  - 그러면 어떻게 구분할 수 있을까? 일치 연산자인 `===`를 이용하면 형 변환 없이도 값을 비교할 수 있다.

  - 일치 연산자는 동등 연산자에 비해 **엄격한** 연산자이기에, 자료형의 동등 여부까지 검사한다.
  - 두 피연산자간의 자료형이 다를 경우 `a === b`는 `false`를 즉시 반환한다. 
  - 일치 연산자는 동등 연산자보다 비교 결과가 명확하기에 에러가 발생할 확률을 줄여준다.

```javascript
// comparison.html
alert(0 == false); // t
alert('' == false); // t
alert(0 === false); // f, 피연산자의 형이 다르기 때문
```

#### null이나 undefined와 비교하기

- 일치 연산자를 이용해 null과 undefined를 비교하면 두 값의 자료형이 다르기에 거짓이 반환된다.
- 동등 연산자를 이용해 비교하면 true가 반환된다.
  - null은 undefined와만 같다. 다른 값과의 비교에서는 false가 반환된다.

```javascript
// comparison.html
alert(null === undefined); // f 일치 연산자
alert(null == undefined); // t 동등 연산자
```

- 산술 연산자나 기타 비교 연산자를 이용한 비교
  - null과 undefined는 숫자형으로 변환된다. null은 0, undefined는 NaN으로 변한다.
- null과 0
  - (3)에서 null은 0보다 크거나 같다 했기에 (1)이나 (2)중 하나는 참이어야 하지만 둘 다 거짓을 반환한다.
  - 동등 연산자와 기타 비교 연산자의 동작 방식이 다르기 때문에 생기는 문제이다.
  - (1)이 거짓,  (3)이 참을 반환하는 이유는 null이 숫자형으로 변환되어 0이 되기 때문이다. 
  - 그러나 동등 연산자는 피연산자가 undefined나 null일 때 형 변환을 하지 않는다.
  - undefined와 null를 비교하는 경우에만 true를 반환하고, 그 이외의 경우(null이나 undefined를 다른 값과 비교할 때)는 무조건 false를 반환한다. 이런 이유로 (2)가 거짓이 된다.

```javascript
// comparison.html
alert(null > 0); // f (1)
alert(null == 0); // f (2)
alert(null >= 0); // t (3)
```

- 비교가 불가능한 undefined
  - undefined를 다른 값이랑 비교해서는 안 된다!!
  - (1)과 (2)에서는 undefined가 NaN으로 변환되는데(숫자형으로의 변환), NaN이 피연산자인 경우 비교 연산자는 항상 false를 반환하기 때문이다.
  - undefined는 null이나 undefined와 같고, 그 이외의 값과는 다르기 때문에 (3)은 거짓을 반환한다.

```javascript
// comparison.html
alert(undefined > 0); // f (1)
alert(undefined < 0); // f (2)
alert(undefined == 0); // f (3)
```

- 일치 연산자를 제외한 비교 연산자의 피연산자에 undefined나 null이 오지 않도록 주의하자!
- 변수가 undefined나 null이 될 수 있다 생각되면 이를 별도로 처리하는 코드를 추가하자.

## 10. if와 '?'를 사용한 조건 처리

- `if`
  - `if(...)`문은 괄호 안에 들어가는 조건을 평가하는데, 그 결과가 `true`이면 코드 블록이 실행된다.
  - if문 안의 문장이 하나라면 중괄호를 꼭 쓰지 않아도 된다. 그렇지만 코드의 가독성을 위해 조건이 참인 경우 실행되는 구문이 한 줄이더라도 중괄호로 코드를 감싸주는 편이다.

```javascript
// if.html
let year = prompt('올해는 몇년도인가요?');
if (year == 2020) alert('맞았습니다!');

let year = prompt('올해는 몇년도인가요?');
if (year == 2020) {         // 중괄호 사용
    alert('맞았습니다!');
    alert('굉장한데요?');
}
```

- 불린형으로의 변환
  - if문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환한다.
    - 숫자 0, 빈 문자열 "", null, undefined, NaN은 불린형으로 변환시 모두 false가 된다.
    - 이 외의 값들은 불린형으로 변환시 true이다.
    - 평가를 통해 확정된 불린값을 if문에 전달할 수도 있다.

```javascript
// if.html
if (0) {   // 아래의 구문은 실행되지 않을 것이다. 0은 false이다
    alert('안녕하세요') 
}

if (1) {  // 아래의 구문은 1이 true이기에 실행된다.
    alert('안녕')
}

let year = 2020;
let cond = (year == 2020);   // 평가를 통해 cond는 true가 된다.
if (cond) {  // 그러므로 아래의 구문이 실행될 것이다.
    alert('2020!')
}
```

- `else`절
  - if문에는 `else`절을 붙일 수 있다. else 뒤에 이어지는 코드 블록은 조건이 거짓일 때 실행된다.

```javascript
// if.html
let year = prompt('올해는 몇년도인가요?');
if (year == 2020) {
    alert('맞았습니다!');
} else {
    alert('틀렸습니다!'); // 2020 이외의 값을 입력한 경우
}
```

- `else if`로 복수 조건 처리하기
  - 약간의 차이가 있는 조건 여러개를 처리해야 할 때 `else if`를 사용할 수 있다.
  - 예시에서, JS는 조건 (year < 2021)을 먼저 확인한다. 거짓이라면, 다음 조건 year > 2010을 확인한다. 이것마저 거짓이라면, else절 아래의 구문을 실행한다.
  - if ~ else if ~ else에서 마지막에 붙는 else는 선택 사항이다.

```javascript
// if.html
let year = prompt('올해는 몇년도인가요?');
if (year > 2021) {        // 2021보다 큰 경우 
    alert('맞았습니다!');
} else if (year > 2010) {
  	alert('절반만 맞았습니다'); // 2010보다 큰 경우
} else {
    alert('틀렸습니다!'); // 그 외의 값을 입력한 경우
}
```

- 조건부 연산자 `?`
  - 조건에 따라 다른 값을 변수에 할당해야 할 때, 물음표 연산자라고도 불리는 조건부 연산자를 사용하면 if ~ else 구문을 짧게 변형할 수 있다.
  - 조건부 연산자는 물음표 `?`로 표시한다. 피연산자가 3개이기에 `삼항 연산자`라고도 부른다. JS에서 삼항 연산자는 조건부 연산자가 유일하다.
  - `a ? b : c` 형태의 구문에서 평가 대상인 a가 true라면 b가, false라면 c가 반환된다.
  - 아래의 예시에서 (age > 18) 부분의 괄호는 생략 가능하다. 물음표 연산자는 우선순위가 낮기에 비교 연산자 ` >`가 실행되고 난 뒤에 실행된다. 역시 가독성 향상을 위해 괄호를 쓰는 것을 권장한다.

```javascript
// if.html
let accessAllowed;
let age = prompt('나이를 입력해주세요', '');

if (age > 18) {
    accessAllowed = true;
} else {
    accessAllowed = false;
}

// 이런 if ~ else 구문을 ?로 바꾸면..
let age = prompt('나이를 입력하세요', '');
let accessAllowed = (age > 18) ? true : false; // 간단해진다!
```

- 다중 `?`
  - 물음표 연산자 `?`를 여러개 연결하면 복수의 조건을 처리할 수 있다.
  - 첫 물음표에서는 조건문 age < 3을 검사한다. 그 결과가 참이면 구문을 수행하고, 거짓인 경우 `:`에 이어지는 조건문 age < 20을 검사한다. 거짓인 경우 `:`에 이어지는 조건문 age < 22를 검사하고, 거짓인 경우 age < 100, 이 조건문도 거짓인 경우 마지막 `:` 이후의 표현식을 반환한다.
  - 이를 기존의 `if ~ else if ~ else`식으로 표현할수도 있다.

```javascript
// if.html
let age = prompt('나이를 입력하세요', '');

let message = (age < 3) ? '아기야 안녕?' :
    (age < 20) ? '안녕? 학교는 재밌니?' :
    (age < 22) ? '안녕? 군대는 다녀왔니?' :
    (age < 100) ? '안녕하세요 어르신!' :
    '인간을 초월하셨군요!';
alert(message);
```

```javascript
// if.html
let age = prompt('나이를 입력하세요!', '');

if (age < 3) {
    message = '아기야 안녕?'
} else if (age < 20) {
    message = '안녕? 학교는 재밌니?'
} else if (age < 22) {
    message = '안녕? 군대는 다녀왔니?'
} else if (age < 100) {
    message = '안녕하세요 어르신!'
} else {
    message = '인간이 아니시군요!'
}

alert(message)
```

- 부적절한 `?`
  - 흔치는 않지만 물음표를 if의 대용으로 사용할 수도 있다.
  - 조건의 검사 결과에 따라 `?` 뒤에 이어지는 첫번째 혹은 두번째 표현식이 실행될 것이다.
  - 그러나 이런 식으로 물음표 연산자를 사용하는 것은 좋지 않은데, if문을 사용할 때보다 코드 길이가 줄어든다는 것은 매력적이지만, 가독성이 떨어진다는 문제가 있기 때문이다. 
  - 물음표 연산자는 조건에 따라 반환 값을 달리해야 할 때 사용하고, 여러 분기를 만들 때는 if를 쓰자.

```javascript
// if.html
let bung = prompt('붕어빵은 얼마인가요?', '');

(bung == '1000') ?
    alert('맞았습니다!') : alert('틀렸습니다');
```

```javascript
// if.html
let bunguh = prompt('붕어빵 얼마에요?', '');
if (bunguh == 1000) {
    alert('맞았습니다! 3개를 드릴게요.');
} else {
    alert('틀렸습니다! 한개만 드릴게요.');
}
```

